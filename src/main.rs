/*
 * Take some html like:
 *
 * ```
 * <html>
 *   <head>
 *     <title> <!--@ get_file_name @--> </title>
 *   </head>
 *   <body>
 *     <p> Hii </p>
 *     <!--@ insert_file ./foo.html @-->
 *     <!--@ debug_print Hello, World! @-->
 *   </body>
 * </html>
 * ```
 *
 * And assume foo.html is:
 *
 * ```
 * <div id="foo">
 *   <p> This is from foo.html! </p>
 * </div>
 * ```
 *
 * Parse out all text between `<!--@` and `@-->` and turn it into a list of
 * whitespace-separated strings. The first string is the command (we will
 * pattern match this), and the rest are the arguments. Pass the arguments to
 * the correct built in command, let it run some side effects if needed, and
 * then replace the preprocessor directive with whatever string the command
 * returns.
 *
 * This might turn into:
 *
 * ```
 * <html>
 *   <head>
 *     <title> index.html </title>
 *   </head>
 *   <body>
 *     <p> Hii </p>
 *     <div id="foo">
 *       <p> This is from foo.html! </p>
 *     </div>
 *   </body>
 * </html>
 * ```
 *
 * And print:
 *
 * ```
 * [DEBUG]: Hello, World!
 * ```
 */

use std::fs::{read_to_string, create_dir_all, File};
use std::io::prelude::Write;
use std::env::{args, set_current_dir};
use std::process::exit;
use std::collections::HashMap;
use std::path::Path;
use serde_json::from_str;

use serde::{Serialize, Deserialize};

pub mod parser;
use parser::parse_data;

macro_rules! error_print {
    ($e: literal) => {
        eprintln!("[ERROR]: {}", format!($e))
    }
}
macro_rules! debug_print {
    ($e: literal) => {
        eprintln!("[DEBUG]: {}", format!($e))
    }
}

#[derive(Serialize, Deserialize)]
struct PPFile {
    input: String,
    output: String,
}
#[derive(Serialize, Deserialize)]
struct PPConfig {
    title: String,
    out_dir: String,
    pp_files: Vec<PPFile>,
    copy_files: Vec<String>
}

fn main() {
    let args: Vec<String> = args().collect();
    let pp_dir = &args[1];
    set_current_dir(pp_dir)
        .expect(format!("Couldn't change directories to: {pp_dir}").as_str());
    let pp_file = read_to_string("pp.json")
        .expect("Couldn't read pp.json in directory");
    let pp_config: PPConfig = from_str(&pp_file)
        .expect("Couldn't parse pp.json");
    create_dir_all(&pp_config.out_dir)
        .expect("Couldn't make out_dir");
    for file in &pp_config.pp_files {
        let oup = format!("{}/{}", &pp_config.out_dir, &file.output);
        let inp = &file.input;
        debug_print!("Generating file: {oup} from: {inp}");
        preprocess_file(&pp_config, &file.input, &oup);
    }
    for file in &pp_config.copy_files {
        let out_file = format!("{}/{file}", &pp_config.out_dir);
        if !Path::new(&out_file).exists() {
            debug_print!("Copying file: {file}");
            std::fs::copy(file, out_file)
                .expect(format!("Couldn't copy file: {file}").as_str());
        }
    }
}

fn preprocess_file(
    pp_config: &PPConfig,
    in_filename: &str,
    out_filename: &str
) {
    let input = read_to_string(in_filename)
        .expect(format!("Could'nt read file: {in_filename}").as_str());
    let mut output = input.clone();
    loop {
        let new_output = parse_data(&output, "<!--@", "@-->", |strs| {
            pp(&pp_config, strs.clone())
        });
        if output == new_output { break; }
        output = new_output;
    };
    File::create(out_filename)
        .expect(format!("Couldn't create file: {out_filename}").as_str())
        .write_all(format!(
            concat!(
                "<!-- This page was (partially) generated by a HTML/CSS",
                " preprocessor, available at",
                " https://github.com/JazTB/html_preprocessor -->{}"
            ),
            output
        ).as_bytes())
        .expect(format!("Couldn't write to file: {out_filename}").as_str());
}

fn pp(pp_config: &PPConfig, strings: Vec<String>) -> String {
    let directive_name = &strings[0];
    let args = &strings[1..];
    match directive_name.as_str() {
        "css" => {
            create_dir_all(format!("{}/css", &pp_config.out_dir))
                .expect("Couldn't make css dir");
            let file_name = &args[0];
            let out_filename = &args[1];
            debug_print!("Reading file: {file_name}");
            let out_file =
                format!("{}/css/{}", &pp_config.out_dir, out_filename);
            let css_string = read_to_string(file_name)
                .expect(format!("Couldn't read file: {file_name}").as_str());
            let string = preprocess_css(&pp_config, css_string);
            File::create(&out_file)
                .expect(
                    format!("Couldn't create file: {out_file}").as_str()
                )
                .write_all(string.as_bytes())
                .expect(
                    format!("Couldn't write to file: {out_file}").as_str()
                );
            format!("<link rel=\"stylesheet\" href=\"/css/{out_filename}\">")
        }
        "js" => {
            create_dir_all(format!("{}/js", &pp_config.out_dir))
                .expect("Couldn't make js dir");
            let file_name = &args[0];
            debug_print!("Reading file: {file_name}");
            let out_filename =
                format!("{}/js/{}", pp_config.out_dir, file_name);
            let string = read_to_string(file_name)
                .expect("Couldn't read file: {file_name}");
            File::create(&out_filename)
                .expect(
                    format!("Couldn't create file: {out_filename}").as_str()
                )
                .write_all(string.as_bytes())
                .expect(
                    format!("Couldn't write to file: {out_filename}").as_str()
                );
            format!("<script src=\"/js/{file_name}\"></script>")
        }
        "js_module" => {
            create_dir_all(format!("{}/js", &pp_config.out_dir))
                .expect("Couldn't make js dir");
            let file_name = &args[0];
            debug_print!("Reading file: {file_name}");
            let out_filename =
                format!("{}/js/{}", pp_config.out_dir, file_name);
            let string = read_to_string(file_name)
                .expect("Couldn't read file: {file_name}");
            File::create(&out_filename)
                .expect(
                    format!("Couldn't create file: {out_filename}").as_str()
                )
                .write_all(string.as_bytes())
                .expect(
                    format!("Couldn't write to file: {out_filename}").as_str()
                );
            format!("<script type=\"module\" src=\"/js/{file_name}\"></script>")
        }
        "title" => {
            format!("<title>{}</title>", pp_config.title)
        }
        "insert_file" => {
            let file_name = &args[0];
            debug_print!("Reading file: {file_name}");
            read_to_string(file_name)
                .expect(format!("Couldn't read file: {file_name}").as_str())
        }
        "debug_print" => {
            let string = args.join(" ");
            debug_print!("{string}");
            "".to_owned()
        }
        "button" => {
            let link = &args[0];
            let class = &args[1];
            let text = &args[2..].join(" ");
            format!("<a href={link}><button class={class}>{text}</button></a>")
        }
        "js_button" => {
            let onclick = &args[0];
            let class = &args[1];
            let text = &args[2..].join(" ");
            format!("<button class={class} onclick={onclick}>{text}</button>")
        }
        invalid_name => {
            error_print!("Invalid PP directive: {invalid_name}");
            exit(1);
        }
    }
}

struct PPCtx {
    vars: HashMap<String, String>
}
fn preprocess_css(pp_config: &PPConfig, contents: String) -> String {
    let mut pp_ctx = PPCtx{ vars: HashMap::new() };
    let mut output: String = contents.clone();
    loop { 
        let new_output = parse_data(&output, "/*@", "@*/", |strs| {
            pp_css(&pp_config, &mut pp_ctx, strs.clone())
        });
        if output == new_output { break; }
        output = new_output;
    }
    format!(
        "{}\n{output}",
        concat!(
            "/* This page was (partially) generated by a HTML/CSS",
            " preprocessor, available at",
            " https://github.com/JazTB/html_preprocessor */"
        )
    )
}

fn pp_css(_pp_config: &PPConfig, ctx: &mut PPCtx, strings: Vec<String>) -> String {
    let directive_name = &strings[0];
    let args = &strings[1..];
    match directive_name.as_str() {
        "set" => {
            ctx.vars.insert(args[0].clone(), args[1].clone());
            "".to_owned()
        }
        "get" => {
            ctx.vars.get(&args[0])
                .expect(
                    format!("Var: {} doesn't exist in css", &args[0]).as_str()
                )
                .clone()
        }
        invalid_name => {
            error_print!("Invalid CSS PP diretive: {invalid_name}");
            exit(1);
        }
    }
}
